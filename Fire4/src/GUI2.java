
import java.awt.event.MouseEvent;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JMenuItem;
import oracle.spatial.geometry.JGeometry;
import oracle.spatial.network.lod.LODNetworkException;
import oracle.spatial.network.lod.LogicalSubPath;
import oracle.spatial.network.lod.PointOnNet;
import oracle.spatial.network.lod.util.PrintUtility;
import oracle.spatial.network.lod.LogicalPath;
import oracle.sql.STRUCT;
import org.jdesktop.swingx.autocomplete.AutoCompleteDecorator;
import org.openstreetmap.gui.jmapviewer.Coordinate;
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author M&M
 */
public class GUI2 extends javax.swing.JFrame {

    ConnectManager cm;
    boolean drawPolygon, unclosedPolygon;
    int count;
    String query;
    ResultSet rs;
    JGeometry geo;
    STRUCT st;
    String buildingName;
    PrintStream writer;
    long[] pathnodes;
    Vector<String> addresses;
    String stID;
    Date date;

    /**
     * Creates new form GUI2
     */
    public GUI2() {
        addresses = new Vector<>();
        addresses = readAddresses("buildingsNode.txt");
        date = new Date();
        initComponents();
        map.setDisplayPositionByLatLon(59.327, 18.07, 12);

        jComboAddress.setModel(new javax.swing.DefaultComboBoxModel(addresses));
        AutoCompleteDecorator.decorate(this.jComboAddress);
        cm = new ConnectManager();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        jPopupMenu1 = new javax.swing.JPopupMenu();
        jTabbedPane2 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        btnSubmit = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextAreaInfo = new javax.swing.JTextArea();
        lblCoordination = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jComboAddress = new javax.swing.JComboBox();
        rbExt = new javax.swing.JRadioButton();
        rbLocateFire = new javax.swing.JRadioButton();
        rbWater = new javax.swing.JRadioButton();
        lblQuery = new javax.swing.JLabel();
        rbClosedRoad = new javax.swing.JRadioButton();
        rbFixedroad = new javax.swing.JRadioButton();
        jPanel2 = new javax.swing.JPanel();
        rbRange = new javax.swing.JRadioButton();
        rbWholeRegion = new javax.swing.JRadioButton();
        cbFireStation = new javax.swing.JCheckBox();
        cbWater = new javax.swing.JCheckBox();
        cbOnFire = new javax.swing.JCheckBox();
        jLabel1 = new javax.swing.JLabel();
        jSeparator3 = new javax.swing.JSeparator();
        btnSearch = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextInfo2 = new javax.swing.JTextArea();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        cbExt = new javax.swing.JCheckBox();
        jDateFrom = new com.toedter.calendar.JDateChooser();
        jDateTo = new com.toedter.calendar.JDateChooser();
        lblCoordination1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        map = new MapViewer();

        jPopupMenu1.setLabel("");
        jPopupMenu1.setMaximumSize(new java.awt.Dimension(60, 60));
        jPopupMenu1.setMinimumSize(new java.awt.Dimension(60, 60));
        jPopupMenu1.setPreferredSize(null);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(1070, 710));

        jTabbedPane2.setMinimumSize(new java.awt.Dimension(250, 710));

        btnSubmit.setFont(new java.awt.Font("Times New Roman", 3, 14)); // NOI18N
        btnSubmit.setText("Submit");
        btnSubmit.setToolTipText("");
        btnSubmit.setEnabled(false);
        btnSubmit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSubmitActionPerformed(evt);
            }
        });

        jTextAreaInfo.setEditable(false);
        jTextAreaInfo.setColumns(20);
        jTextAreaInfo.setRows(5);
        jScrollPane2.setViewportView(jTextAreaInfo);

        lblCoordination.setFont(new java.awt.Font("Times New Roman", 3, 18)); // NOI18N
        lblCoordination.setText("INFO:");

        jComboAddress.setEditable(true);
        jComboAddress.setMaximumRowCount(3);
        jComboAddress.setEnabled(false);

        buttonGroup1.add(rbExt);
        rbExt.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbExt.setText("Extinguished");
        rbExt.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbExtActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbLocateFire);
        rbLocateFire.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbLocateFire.setText("locate fire");
        rbLocateFire.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbLocateFireActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbWater);
        rbWater.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbWater.setText("Find closest hydrant");
        rbWater.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbWaterActionPerformed(evt);
            }
        });

        lblQuery.setFont(new java.awt.Font("Times New Roman", 3, 18)); // NOI18N
        lblQuery.setText("Select type of query:");

        buttonGroup1.add(rbClosedRoad);
        rbClosedRoad.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbClosedRoad.setText("Closed road");
        rbClosedRoad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbClosedRoadActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbFixedroad);
        rbFixedroad.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbFixedroad.setText("Fixed road");
        rbFixedroad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbFixedroadActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jSeparator2)
                        .addContainerGap())
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jScrollPane2)
                        .addGap(17, 17, 17))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(rbClosedRoad)
                                .addGap(18, 18, 18)
                                .addComponent(rbFixedroad))
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(lblCoordination)
                                .addComponent(lblQuery)
                                .addComponent(rbWater)
                                .addComponent(jComboAddress, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(btnSubmit, javax.swing.GroupLayout.Alignment.TRAILING))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(rbLocateFire)
                                .addGap(18, 18, 18)
                                .addComponent(rbExt)))
                        .addGap(0, 35, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(lblQuery)
                .addGap(18, 18, 18)
                .addComponent(rbWater)
                .addGap(26, 26, 26)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(rbClosedRoad)
                    .addComponent(rbFixedroad))
                .addGap(30, 30, 30)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(rbLocateFire)
                    .addComponent(rbExt))
                .addGap(18, 18, 18)
                .addComponent(jComboAddress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(49, 49, 49)
                .addComponent(btnSubmit)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblCoordination)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(55, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Query", jPanel1);

        buttonGroup1.add(rbRange);
        rbRange.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbRange.setText("Range");
        rbRange.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbRangeActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbWholeRegion);
        rbWholeRegion.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        rbWholeRegion.setText("Whole region");
        rbWholeRegion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbWholeRegionActionPerformed(evt);
            }
        });

        cbFireStation.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        cbFireStation.setText("Fire Stations");
        cbFireStation.setPreferredSize(null);

        cbWater.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        cbWater.setText("Hydrants");

        cbOnFire.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        cbOnFire.setText("On fire");

        jLabel1.setFont(new java.awt.Font("Times New Roman", 3, 18)); // NOI18N
        jLabel1.setText("What to search on the map:");

        btnSearch.setFont(new java.awt.Font("Times New Roman", 1, 11)); // NOI18N
        btnSearch.setText("Search");
        btnSearch.setEnabled(false);
        btnSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSearchActionPerformed(evt);
            }
        });

        jTextInfo2.setColumns(20);
        jTextInfo2.setRows(5);
        jScrollPane3.setViewportView(jTextInfo2);

        jLabel2.setFont(new java.awt.Font("Times New Roman", 3, 18)); // NOI18N
        jLabel2.setText("Choose range:");

        jLabel3.setText("From");

        jLabel4.setText("To");

        cbExt.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        cbExt.setText("Extinguished");

        jDateFrom.setDate(date);

        jDateTo.setDate(date);

        lblCoordination1.setFont(new java.awt.Font("Times New Roman", 3, 18)); // NOI18N
        lblCoordination1.setText("INFO:");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSeparator3)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jDateFrom, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jDateTo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(btnSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(rbWholeRegion)
                                .addGap(33, 33, 33)
                                .addComponent(rbRange))
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(cbFireStation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(cbWater))
                                .addGap(6, 6, 6)
                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(cbExt)
                                    .addComponent(cbOnFire)))
                            .addComponent(jLabel3)
                            .addComponent(jLabel4)
                            .addComponent(lblCoordination1))
                        .addGap(0, 25, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cbWater)
                    .addComponent(cbExt))
                .addGap(21, 21, 21)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cbFireStation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cbOnFire))
                .addGap(18, 18, 18)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addComponent(jLabel2)
                .addGap(33, 33, 33)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(rbWholeRegion)
                    .addComponent(rbRange))
                .addGap(18, 18, 18)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jDateFrom, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 10, Short.MAX_VALUE)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnSearch)
                    .addComponent(jDateTo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(22, 22, 22)
                .addComponent(lblCoordination1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 124, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Report", jPanel2);

        jTextArea1.setEditable(false);
        jTextArea1.setBackground(new java.awt.Color(0, 0, 0));
        jTextArea1.setColumns(20);
        jTextArea1.setForeground(new java.awt.Color(255, 255, 255));
        jTextArea1.setRows(5);
        jTextArea1.setPreferredSize(null);
        jTextArea1.setRequestFocusEnabled(false);
        jTextArea1.setSelectedTextColor(new java.awt.Color(0, 0, 0));
        jTextArea1.setSelectionColor(new java.awt.Color(255, 255, 255));
        jScrollPane1.setViewportView(jTextArea1);

        map.setToolTipText("");
        map.setPreferredSize(new java.awt.Dimension(1070, 2000));
        map.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                mapMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 276, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(map, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addComponent(jScrollPane1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 544, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 72, Short.MAX_VALUE))
                    .addComponent(map, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnSubmitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSubmitActionPerformed
        try {
            // TODO add your handling code here:

            map.removeAllMapMarkers();

            if (rbClosedRoad.isSelected()) {
                try {
                    String buildingId;
                    String address = (String) jComboAddress.getSelectedItem();

                    query = "SELECT * FROM Buildings "
                            + "WHERE building_name= '" + address + "'";

                    displayQuery(query);
                    count++;
                    rs = cm.fetchData(query);
                    if (rs.next()) {
                        st = (STRUCT) rs.getObject("geom");
                        buildingId = rs.getString("building_ID");
                        geo = JGeometry.load(st);

                        //zoom to selected address
                        map.setDisplayPositionByLatLon(geo.getPoint()[1], geo.getPoint()[0], 18);

                        //to find closest node to be inactivated due to construction
                        int nodeId = nnToBuilding(buildingId);

                        //inactive the street node that is under cunstruction
                        query = "UPDATE FIRE_NODE$ SET active = 'N' WHERE node_ID = '" + nodeId + "'";
                        jTextAreaInfo.setText("The street marked as under construction \n");

                        displayQuery(query);
                        count++;
                        rs = cm.fetchData(query);
                        
                        //add point to the list of closed streets
                        map.underConstruct.clear();
                        findUnderConstruct();

                        map.removeAllMapMarkers();
                        repaint();

                    } else {
                        jTextAreaInfo.setText("The address is wrong \n");
                    }
                } catch (SQLException ex) {
                    Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
                }

            }

            if (rbFixedroad.isSelected()) {
                try {
                    String buildingId;
                    String address = (String) jComboAddress.getSelectedItem();

                    query = "SELECT * FROM Buildings "
                            + "WHERE building_name= '" + address + "'";

                    displayQuery(query);
                    count++;
                    rs = cm.fetchData(query);
                    if (rs.next()) {
                        st = (STRUCT) rs.getObject("geom");
                        buildingId = rs.getString("building_ID");
                        geo = JGeometry.load(st);

                        //zoom to selected address
                        map.setDisplayPositionByLatLon(geo.getPoint()[1], geo.getPoint()[0], 18);

                        //to find the node to be activated after maintenance
                        int nodeId = nnToBuilding(buildingId);

                        //activate the street node that is fixed
                        query = "UPDATE FIRE_NODE$ SET active = 'Y' WHERE node_ID = '" + nodeId + "'";
                        jTextAreaInfo.setText("The street marked as open again \n");

                        displayQuery(query);
                        count++;
                        rs = cm.fetchData(query);
                        
                        //remove point from the list of closed streets
                        map.underConstruct.clear();
                        findUnderConstruct();

                        map.removeAllMapMarkers();
                        repaint();

                    } else {
                        jTextAreaInfo.setText("The address is wrong \n");
                    }
                } catch (SQLException ex) {
                    Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            if (rbLocateFire.isSelected()) {
                map.route.clear();

                try {

                    //send the query to find which building is clicked.
                    //in other words, this query help us to determine the clicked point is inside of which building.
                    String buildingId;
                    int onFire;
                    String address = (String) jComboAddress.getSelectedItem();

                    query = "SELECT * FROM Buildings "
                            + "WHERE building_name= '" + address + "'";

                    displayQuery(query);
                    count++;
                    rs = cm.fetchData(query);
                    if (rs.next()) {
                        do {
                            st = (STRUCT) rs.getObject("geom");
                            buildingId = rs.getString("building_ID");
                            onFire = rs.getInt("onFire");
                            buildingName = rs.getString("building_name");
                            geo = JGeometry.load(st);

                            map.setDisplayPositionByLatLon(geo.getPoint()[1], geo.getPoint()[0], 18);

                            if (onFire == 1) {
                                jTextAreaInfo.setText("The building is already in the onfire list \n");
                                map.removeAllMapMarkers();
                                repaint();
                            } else {
                                map.onFire.add(new Building(geo.getPoint(), buildingName));
                                query = "UPDATE Buildings SET onFire = '1' WHERE building_ID = '" + buildingId + "'";
                                cm.execute(query);
                                displayQuery(query);
                                count++;
                                map.removeAllMapMarkers();
                                repaint();
                                displayQuery(query);
                                count++;
                            }
                        } while (rs.next());
                        //to find closest firestation
                        int buildingNode = nnToBuilding(buildingId);
                        HashMap<Integer, String> fsNode = closestFireStations(buildingId);
                        pathnodes = getShortestPathStation(buildingNode, fsNode);

                        //add path nodes to the route to be drawn
                        for (int j = 0; j < pathnodes.length; j++) {
                            query = "SELECT Fire_node$.geometry from Fire_node$ "
                                    + "WHERE Fire_node$.node_ID=" + (int) pathnodes[j];
                            rs = cm.fetchData(query);
                            if (rs.next()) {
                                st = (STRUCT) rs.getObject("geometry");
                                geo = JGeometry.load(st);
                                Coordinate coord = new Coordinate(geo.getPoint()[1], geo.getPoint()[0]);
                                map.route.add(coord);

                            }
                        }

                        query = "INSERT INTO FIRE_HISTORY VALUES('" + buildingId + "','" + stID + "', SYSDATE)";
                        displayQuery(query);
                        count++;
                        cm.execute(query);
                        map.removeAllMapMarkers();
                        repaint();

                    } else {
                        jTextAreaInfo.setText("The address is wrong \n");
                    }
                } catch (SQLException | LODNetworkException ex) {
                    Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            if (rbExt.isSelected()) {
                try {

                    //send the query to find geom of the building .
                    String buildingId;
                    int onFire;
                    String address = (String) jComboAddress.getSelectedItem();

                    query = "SELECT * FROM Buildings "
                            + "WHERE building_name= '" + address + "'";

                    displayQuery(query);
                    count++;
                    rs = cm.fetchData(query);
                    if (rs.next()) {
                        do {
                            st = (STRUCT) rs.getObject("geom");
                            buildingId = rs.getString("building_ID");
                            onFire = rs.getInt("onFire");
                            buildingName = rs.getString("building_name");
                            geo = JGeometry.load(st);

                            map.setDisplayPositionByLatLon(geo.getPoint()[1], geo.getPoint()[0], 18);

                            if (onFire == 1) {
                                jTextAreaInfo.setText("The building is removed from onfire list \n");
                                /* set in java is not supposed to add duplicate entry, but it does.
                                 * it was working perfectly when comparing two buildings objects
                                 * but suddenly the remove and add methods of set stopped working properly
                                 * the equals method of the building object examined several times and it works correctly
                                 * so what is the problem???????*/

                                //                            map.onFire.remove(new Building(geo.getPoint(), buildingName));

                                query = "UPDATE Buildings SET onFire = '0' WHERE building_ID = '" + buildingId + "'";
                                cm.execute(query);
                                displayQuery(query);
                                count++;
                                map.onFire.clear();
                                findOnFire();
                                map.removeAllMapMarkers();
                                repaint();
                            } else {
                                jTextAreaInfo.setText("The building is not on fire \n");
                                map.removeAllMapMarkers();
                                repaint();
                            }
                        } while (rs.next());
                    } else {
                        jTextAreaInfo.setText("The address is wrong \n");
                    }

                } catch (SQLException ex) {
                    Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            map.removeAllMapMarkers();
            repaint();
            cm.statement.close();
        } catch (SQLException ex) {
            Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
        }



    }//GEN-LAST:event_btnSubmitActionPerformed

    private void rbRangeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbRangeActionPerformed
        // TODO add your handling code here:
        map.resetMap();
        map.removeAllMapMarkers();
        map.removeAllMapPolygons();
        map.removePoly();
        jTextAreaInfo.setText(null);
        jComboAddress.setEnabled(false);
        map.resetMap = true;
        cbFireStation.setEnabled(true);
        cbOnFire.setEnabled(true);
        cbExt.setEnabled(true);
        cbWater.setEnabled(true);
        drawPolygon = true;
        unclosedPolygon = true;
        btnSearch.setEnabled(false);
        btnSubmit.setEnabled(false);

    }//GEN-LAST:event_rbRangeActionPerformed

    private void rbExtActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbExtActionPerformed
        // TODO add your handling code here
        map.resetMap();
        findOnFire();
        map.removePoly();
        jComboAddress.setEnabled(true);
        jTextAreaInfo.setText(null);
        cbFireStation.setEnabled(false);
        cbFireStation.setSelected(false);
        cbOnFire.setEnabled(false);
        cbOnFire.setSelected(false);
        cbExt.setEnabled(false);
        cbWater.setEnabled(false);
        cbWater.setSelected(false);
        btnSubmit.setEnabled(true);
        btnSearch.setEnabled(false);
        map.resetMap = false;
        drawPolygon = false;
    }//GEN-LAST:event_rbExtActionPerformed

    private void rbLocateFireActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbLocateFireActionPerformed
        map.resetMap();
        findOnFire();
        map.removePoly();
        jComboAddress.setEnabled(true);
        cbFireStation.setEnabled(false);
        cbFireStation.setSelected(false);
        cbOnFire.setEnabled(false);
        cbExt.setEnabled(false);
        cbOnFire.setSelected(false);
        cbWater.setEnabled(false);
        cbWater.setSelected(false);
        btnSubmit.setEnabled(true);
        btnSearch.setEnabled(false);
        map.resetMap = false;
        drawPolygon = false;
    }//GEN-LAST:event_rbLocateFireActionPerformed

    private void rbWholeRegionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbWholeRegionActionPerformed
        // TODO add your handling code here:
        map.resetMap();
        map.removeAllMapMarkers();
        map.removeAllMapPolygons();
        jComboAddress.setEnabled(false);
        jTextAreaInfo.setText(null);
        map.resetMap = true;
        cbFireStation.setEnabled(true);
        cbOnFire.setEnabled(true);
        cbWater.setEnabled(true);
        cbExt.setEnabled(true);
        btnSearch.setEnabled(true);
        btnSubmit.setEnabled(false);
        map.removePoly();
        drawPolygon = false;
    }//GEN-LAST:event_rbWholeRegionActionPerformed

    private void rbWaterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbWaterActionPerformed
        // TODO add your handling code here:
        map.resetMap();
        findOnFire();
        map.removePoly();
        jComboAddress.setEnabled(false);
        cbFireStation.setEnabled(false);
        cbExt.setEnabled(false);
        cbFireStation.setSelected(false);
        cbOnFire.setEnabled(false);
        cbOnFire.setSelected(false);
        cbWater.setEnabled(false);
        cbWater.setSelected(false);
        btnSubmit.setEnabled(false);
        btnSearch.setEnabled(false);
        map.resetMap = false;
        drawPolygon = false;
    }//GEN-LAST:event_rbWaterActionPerformed

    private void mapMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mapMouseClicked
        // TODO add your handling code here:

        jPopupMenu1.removeAll();
        //if the range radiobutton is selected and we want to draw a polygon on the map
        if (drawPolygon && unclosedPolygon) {
            drawRange(evt);
        }
        // to show building info  on the map
        if (rbLocateFire.isSelected() && evt.getButton() == 1) {
            try {

                //send the query to find which building is clicked.
                //in other words, this query help us to determine the clicked point is inside of which building.

                int floors;
                int residents;
                query = "SELECT * FROM Buildings "
                        + "WHERE sdo_geom.relate(Buildings.geom, 'anyinteract',"
                        + "SDO_GEOMETRY(2001,4326,SDO_POINT_TYPE(" + map.getPosition(evt.getPoint()).getLon() + "," + map.getPosition(evt.getPoint()).getLat() + "," + "NULL),"
                        + "NULL, NULL), 5)='TRUE'";

                displayQuery(query);
                count++;
                rs = cm.fetchData(query);
                while (rs.next()) {
//                    st = (STRUCT) rs.getObject("geom");
                    buildingName = rs.getString("building_name");
                    residents = rs.getInt("no_Residents");
                    floors = rs.getInt("floors");
                    JMenuItem menuItem = new JMenuItem("Address: " + buildingName);
                    jPopupMenu1.add(menuItem);
                    menuItem = new JMenuItem("Residents: " + residents);
                    jPopupMenu1.add(menuItem);
                    menuItem = new JMenuItem("Floors: " + floors);
                    jPopupMenu1.add(menuItem);
                    jPopupMenu1.show(evt.getComponent(), evt.getX(), evt.getY());

                }

//                        map.removeAllMapMarkers();
//                        repaint();
            } catch (SQLException ex) {
                Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
            }

        }

//if we want to find the Closest water resource
        if (rbWater.isSelected() && evt.getButton() == 1) {
            map.route.clear();
            map.waterResources.clear();
            map.buildings.clear();
            map.fireStations.clear();
            try {
                //send the query to find which building is clicked.
                //in other words, this query help us to determine the clicked point is inside of which building.
                String buildingId;
                int onFire;

                // get the clicked point and find corresponding building
                query = "SELECT * FROM Buildings "
                        + "WHERE sdo_geom.relate(Buildings.geom, 'anyinteract',"
                        + "SDO_GEOMETRY(2001,4326,SDO_POINT_TYPE(" + map.getPosition(evt.getPoint()).getLon() + "," + map.getPosition(evt.getPoint()).getLat() + "," + "NULL),"
                        + "NULL, NULL), 8)='TRUE'";

                displayQuery(query);
                count++;
                rs = cm.fetchData(query);
                //if any result returned.
                if (rs.next()) {
                    int buildingNode = 0;
                    List<Integer> hydrantNodes = new ArrayList<>();
                    do {
                        st = (STRUCT) rs.getObject("geom");
                        buildingId = rs.getString("building_ID");
                        onFire = rs.getInt("onFire");
                        buildingName = rs.getString("building_name");

                        geo = JGeometry.load(st);
                        if (onFire == 0) {
                            map.buildings.add(new Building(geo.getPoint(), buildingName));
                        }
                        buildingNode = nnToBuilding(buildingId);

                        // find two of the closest hydrant then see which one has shortest path
                        // e.g. a hydrant is one meter away from the fire but it is behind the building and you have to travel 100 meters, 
                        //but there is another hydrant more far than the first one but the traveling distance is shorter
                        query = "SELECT WaterResources.geom, WaterResources.WaterResourcesIndex"
                                + " FROM WaterResources , Buildings WHERE Buildings.building_ID= '"
                                + buildingId
                                + "' AND SDO_NN(WaterResources.geom, buildings.geom, 'sdo_num_res=2')='TRUE'";
                        ResultSet rs2 = cm.fetchData(query);
                        List<String> wrId = new ArrayList<>();
                        int i = 0;
                        while (rs2.next()) {

                            STRUCT st2 = (STRUCT) rs2.getObject("geom");
                            JGeometry geo2 = JGeometry.load(st2);
                            wrId.add(rs2.getString("WaterResourcesIndex"));
                            map.waterResources.add(geo2.getPoint()[1]);
                            map.waterResources.add(geo2.getPoint()[0]);
                            hydrantNodes.add(nnToHydrant(wrId.get(i)));
                            i++;
                        }
                    } while (rs.next());


                    try {
                        pathnodes = getShortestPathHydrant(buildingNode, hydrantNodes);

                        for (int i = 0; i < pathnodes.length; i++) {
                            query = "SELECT Fire_node$.geometry from Fire_node$ "
                                    + "WHERE Fire_node$.node_ID=" + (int) pathnodes[i];
                            rs = cm.fetchData(query);
                            if (rs.next()) {
                                st = (STRUCT) rs.getObject("geometry");
                                geo = JGeometry.load(st);
                                Coordinate coord = new Coordinate(geo.getPoint()[1], geo.getPoint()[0]);
                                map.route.add(coord);

                            }

                        }

                    } catch (SQLException | LODNetworkException ex) {
                        Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
                    }

                } else {
                    jTextAreaInfo.setText("!!!!PLEASE SELECT A BUILDING!!!! \n");

                }
                map.removeAllMapMarkers();
                repaint();
            } catch (SQLException ex) {
                Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        try {
            cm.statement.close();
        } catch (SQLException ex) {
            Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
        }



    }//GEN-LAST:event_mapMouseClicked

    private void btnSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSearchActionPerformed
        // TODO add your handling code here:

        jTextInfo2.setText("");
        // at least one of the check boxes must be selected in case of whole region or range query 
        if ((rbWholeRegion.isSelected() || rbRange.isSelected()) && !cbFireStation.isSelected() && !cbOnFire.isSelected() && !cbWater.isSelected() && !cbExt.isSelected()) {
            jTextInfo2.setText("Please indicate what to search on the map\n");
            return;
        }
        if ((!rbWholeRegion.isSelected() && !rbRange.isSelected())) {
            jTextInfo2.setText("Please select a radio button\n");
            return;
        }

        map.removeAllMapMarkers();

        //create range WHERE clause
        String buildingIntersetcsRange = "";
        String waterIntersectsRange = "";
        String fsIntersetcsRange = "";

        String andIntersectsRange = "";
        if (rbRange.isSelected()) {
            buildingIntersetcsRange = " sdo_geom.relate(buildings.geom, 'ANYINTERACT', SDO_Geometry(2003,4326,null,SDO_ELEM_INFO_ARRAY(1,1003,1),SDO_ORDINATE_ARRAY("
                    + map.getRangePolygon() + ")), 0.005)='TRUE'";
            fsIntersetcsRange = " WHERE sdo_geom.relate(firestations.geom, 'ANYINTERACT', SDO_Geometry(2003,4326,null,SDO_ELEM_INFO_ARRAY(1,1003,1),SDO_ORDINATE_ARRAY("
                    + map.getRangePolygon() + ")), 0.005)='TRUE'";

            andIntersectsRange = " AND" + buildingIntersetcsRange;
            //buildingIntersetcsRange = " WHERE" + buildingIntersetcsRange;
            waterIntersectsRange = " WHERE sdo_geom.relate(WaterResources.geom, 'ANYINTERACT', SDO_Geometry (2003,4326,null,SDO_ELEM_INFO_ARRAY(1,1003,1),SDO_ORDINATE_ARRAY("
                    + map.getRangePolygon() + ")), 0.01)='TRUE'";
            //map.removePoly();
        }

        if (cbFireStation.isSelected()) {
            try {
                query = "SELECT geom, building_name FROM FireStations  " + fsIntersetcsRange;

                displayQuery(query);
                count++;
                rs = cm.fetchData(query);
                while (rs.next()) {
                    st = (STRUCT) rs.getObject("geom");
                    buildingName = rs.getString("Building_Name");
                    geo = JGeometry.load(st);
                    map.fireStations.add(new Building(geo.getPoint(), buildingName));
                }
            } catch (SQLException ex) {
                Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        if (cbOnFire.isSelected()) {

            try {
                query = "SELECT geom, building_name FROM Buildings WHERE onFire = '1'" + andIntersectsRange;

                displayQuery(query);
                count++;
                rs = cm.fetchData(query);
                while (rs.next()) {
                    st = (STRUCT) rs.getObject("geom");
                    geo = JGeometry.load(st);
                    buildingName = rs.getString("building_name");
                    map.onFire.add(new Building(geo.getPoint(), buildingName));
                }

            } catch (SQLException ex) {
                Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
            }

        }

        if (cbExt.isSelected()) {

            try {
                DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd");
                Date datef = jDateFrom.getDate();
                Date dateT = jDateTo.getDate();
                //check to see if the date is in correct format
                if (datef == null || dateT == null) {
                    jTextInfo2.setText("Please enter date in correct format");
                    return;
                }

                String dateFrom = dateFormat.format(datef);
                String dateTo = dateFormat.format(dateT);

                query = "SELECT BUILDINGS.BUILDING_NAME, BUILDINGS.BUILDING_ID, COUNT(BUILDING_NAME) AS c "
                        + "FROM FIRE_HISTORY INNER JOIN BUILDINGS ON BUILDINGS.BUILDING_ID=FIRE_HISTORY.BUILDING_ID "
                        + "where FIRE_HISTORY.FIRE_DATE>= TO_DATE ('" + dateFrom + "', 'yyyy.MM.dd') "
                        + "AND FIRE_HISTORY.FIRE_DATE<= TO_DATE ('" + dateTo + "', 'yyyy.MM.dd') "
                        + " AND BUILDINGS.onfire= '0' " + andIntersectsRange
                        + "GROUP BY BUILDINGS.BUILDING_NAME, BUILDINGS.BUILDING_ID";
                displayQuery(query);
                count++;
                int fireCounter = 0;
                String bID;
                rs = cm.fetchData(query);

                while (rs.next()) {
                    fireCounter = rs.getInt("c");
                    buildingName = rs.getString("BUILDING_NAME");

                    jTextInfo2.append("# Fire at: " + buildingName + "  " + fireCounter + " time(s)\n\n");
                    jTextInfo2.append("Date                      Station\n");

                    bID = rs.getString("BUILDING_ID");
                    query = "SELECT TO_CHAR(FIRE_HISTORY.FIRE_DATE, 'yyyy.MM.dd') AS d"
                            + ", FIRESTATIONS.BUILDING_NAME as stn "
                            + "FROM FIRE_HISTORY INNER JOIN FIRESTATIONS "
                            + "ON FIRESTATIONS.BUILDING_ID= FIRE_HISTORY.STATION_ID"
                            + " WHERE FIRE_HISTORY.BUILDING_ID='" + bID + "'";
                    displayQuery(query);
                    count++;
                    ResultSet rs2 = cm.fetchData(query);
                    String date;
                    String stName;
                    while (rs2.next()) {
                        date = rs2.getString("d");
                        stName = rs2.getString("stn");
                        jTextInfo2.append(date + "\t  " + stName + "\n");

                    }
                    jTextInfo2.append("\n");

                }


                query = "SELECT BUILDINGS.GEOM "
                        + "FROM FIRE_HISTORY INNER JOIN BUILDINGS ON BUILDINGS.BUILDING_ID=FIRE_HISTORY.BUILDING_ID"
                        + " where FIRE_HISTORY.FIRE_DATE>= TO_DATE ('" + dateFormat.format(datef) + "', 'yyyy.MM.dd')"
                        + " AND FIRE_HISTORY.FIRE_DATE<= TO_DATE ('" + dateFormat.format(dateT) + "', 'yyyy.MM.dd') "
                        + " AND buildings.onfire='0'" + andIntersectsRange;

                displayQuery(query);
                count++;
                rs = cm.fetchData(query);
                while (rs.next()) {
                    st = (STRUCT) rs.getObject("geom");
                    geo = JGeometry.load(st);
                    map.wasOnFire.add(new Building(geo.getPoint(), buildingName));
                }

            } catch (SQLException | NullPointerException ex) {
                Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
            }

        }

        if (cbWater.isSelected()) {
            try {
                query = "SELECT geom FROM WaterResources" + waterIntersectsRange;

                displayQuery(query);
                count++;
                rs = cm.fetchData(query);
                while (rs.next()) {
                    st = (STRUCT) rs.getObject("geom");
                    geo = JGeometry.load(st);
                    map.waterResources.add(geo.getPoint()[1]);
                    map.waterResources.add(geo.getPoint()[0]);
                }

            } catch (SQLException ex) {
                Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);

            }

        }

        unclosedPolygon = true;
        try {
            cm.statement.close();
        } catch (SQLException ex) {
            Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
        }


    }//GEN-LAST:event_btnSearchActionPerformed

    private void rbClosedRoadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbClosedRoadActionPerformed
        // TODO add your handling code here:
        map.resetMap();
        map.removePoly();
        findUnderConstruct();
        jComboAddress.setEnabled(true);
        jTextAreaInfo.setText(null);
        cbFireStation.setEnabled(false);
        cbFireStation.setSelected(false);
        cbOnFire.setEnabled(false);
        cbOnFire.setSelected(false);
        cbExt.setEnabled(false);
        cbWater.setEnabled(false);
        cbWater.setSelected(false);
        btnSubmit.setEnabled(true);
        btnSearch.setEnabled(false);
        map.resetMap = false;
        drawPolygon = false;
    }//GEN-LAST:event_rbClosedRoadActionPerformed

    private void rbFixedroadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbFixedroadActionPerformed
        // TODO add your handling code here:
        map.resetMap();
        findUnderConstruct();
        map.removePoly();
        jComboAddress.setEnabled(true);
        jTextAreaInfo.setText(null);
        cbFireStation.setEnabled(false);
        cbFireStation.setSelected(false);
        cbOnFire.setEnabled(false);
        cbOnFire.setSelected(false);
        cbExt.setEnabled(false);
        cbWater.setEnabled(false);
        cbWater.setSelected(false);
        btnSubmit.setEnabled(true);
        btnSearch.setEnabled(false);
        map.resetMap = false;
        drawPolygon = false;
    }//GEN-LAST:event_rbFixedroadActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI2().setVisible(true);
            }
        });
    }

    private void displayQuery(String query) {
        jTextArea1.append(count + ": " + query + "\n");
        count++;
    }

    private void drawRange(MouseEvent e) {
        // if right clicked then the polygon will be closed by adding the first coordinate as the last one
        if (e.getButton() == 3) {
            if (map.userPoly.size() > 2) {
                map.closePoly();
                btnSearch.setEnabled(true);
                drawPolygon = false;
            }

        } else {
            map.addClickedPoint(map.getPosition(e.getPoint()).getLat(),
                    map.getPosition(e.getPoint()).getLon());
        }
        //call the paintComponent method to draw the polygon

        repaint();
    }

    private void findOnFire() {
        try {
            // TODO add your handling code here:
            query = "SELECT geom, building_name FROM Buildings WHERE onFire = '1'";

            displayQuery(query);

            count++;
            rs = cm.fetchData(query);
            while (rs.next()) {
                st = (STRUCT) rs.getObject("geom");
                geo = JGeometry.load(st);
                buildingName = rs.getString("building_name");
                map.onFire.add(new Building(geo.getPoint(), buildingName));
            }

            map.removeAllMapMarkers();

            repaint();
        } catch (SQLException ex) {
            Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void findUnderConstruct() {
        try {
            // TODO add your handling code here:
            query = "SELECT geometry FROM FIRE_NODE$ WHERE ACTIVE = 'N'";

            displayQuery(query);

            count++;
            rs = cm.fetchData(query);
            while (rs.next()) {
                st = (STRUCT) rs.getObject("geometry");
                geo = JGeometry.load(st);
                map.underConstruct.add(geo.getPoint()[1]);
                map.underConstruct.add(geo.getPoint()[0]);
            }

            map.removeAllMapMarkers();

            repaint();
        } catch (SQLException ex) {
            Logger.getLogger(GUI2.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private int nnToHydrant(String wrId) throws SQLException {
        // find nearest node on the street network to the hydrant
        int pointId = 0;
        query = "SELECT Fire_node$.node_ID FROM Fire_node$ , WaterResources"
                + " WHERE WaterResources.WaterResourcesIndex= '"
                + wrId
                + "' AND SDO_NN(fire_node$.geometry, WaterResources.geom, 'sdo_num_res=1')='TRUE'";
        displayQuery(query);
        count++;
        rs = cm.fetchData(query);
        if (rs.next()) {
            pointId = rs.getInt("node_ID");
        }

        return pointId;
    }

    // find nearest node ID on the street network to the building
    private int nnToBuilding(String buildingId) throws SQLException {
        int pointId = -1;

        query = "SELECT Fire_node$.node_ID FROM Fire_node$ , Buildings WHERE Buildings.building_ID= '"
                + buildingId
                + "' AND SDO_NN(fire_node$.geometry, buildings.geom, 'sdo_num_res=1')='TRUE'";
        displayQuery(query);
        count++;
        rs = cm.fetchData(query);
        if (rs.next()) {
            pointId = rs.getInt("node_ID");
        }

        return pointId;
    }
    // find nearest node ID on the street network to the FS

    private int nnToFireStation(String stationId) throws SQLException {
        int pointId = 0;

        query = "SELECT Fire_node$.node_ID FROM Fire_node$ , firestations WHERE firestations.building_ID= '"
                + stationId
                + "' AND SDO_NN(fire_node$.geometry, firestations.geom, 'sdo_num_res=1')='TRUE'";
        displayQuery(query);
        count++;
        rs = cm.fetchData(query);
        if (rs.next()) {
            pointId = rs.getInt("node_ID");
        }

        return pointId;
    }

    private long[] getShortestPathHydrant(int buildingNode, List<Integer> destination) throws LODNetworkException {
        // TODO add your handling code here:

        long[] pnodes;
        LogicalSubPath subPath1 = cm.analyst.shortestPathDijkstra(new PointOnNet(buildingNode), new PointOnNet(destination.get(0)), null);
        PrintUtility.print(System.out, subPath1, true, 30, 0);
        LogicalPath p1 = subPath1.getReferencePath();
        double cost1 = p1.getCosts()[0];
        if (destination.size() == 1) {
            pnodes = p1.getNodeIds();
            if (cost1 < 1) {
                jTextAreaInfo.setText("Distance: " + Math.round(cost1 * 1000) + " m\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            } else {
                jTextAreaInfo.setText("Distance: " + roundTwoDecimals(cost1) + " Km\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            }
            return pnodes;
        }


        LogicalSubPath subPath2 = cm.analyst.shortestPathDijkstra(new PointOnNet(buildingNode), new PointOnNet(destination.get(1)), null);
        PrintUtility.print(System.out, subPath2, true, 30, 0);
        LogicalPath p2 = subPath2.getReferencePath();
        double cost2 = p2.getCosts()[0];
        if (cost1 < cost2) {
            pnodes = p1.getNodeIds();
            //assuming 30km/h
            if (cost1 < 1) {
                jTextAreaInfo.setText("Distance: " + Math.round(cost1 * 1000) + " m\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            } else {
                jTextAreaInfo.setText("Distance: " + roundTwoDecimals(cost1) + " Km\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            }
        } else {
            pnodes = p2.getNodeIds();
            if (cost1 < 1) {
                jTextAreaInfo.setText("Distance: " + Math.round(cost2 * 1000) + " m\nTravel time: " + minToHour((int) Math.round(cost2 * 2)));
            } else {
                jTextAreaInfo.setText("Distance: " + roundTwoDecimals(cost2) + " Km\nTravel time: " + minToHour((int) Math.round(cost2 * 2)));
            }
        }

        return pnodes;
    }

    private long[] getShortestPathStation(int buildingNode, HashMap<Integer, String> destination) throws LODNetworkException {
        // TODO add your handling code here:
        stID = null;
        long[] pnodes;
        Object[] obj = destination.keySet().toArray();
        LogicalSubPath subPath1 = cm.analyst.shortestPathDijkstra(new PointOnNet(buildingNode), new PointOnNet((int) obj[0]), null);
        PrintUtility.print(System.out, subPath1, true, 30, 0);
        LogicalPath p1 = subPath1.getReferencePath();
        double cost1 = p1.getCosts()[0];
        if (destination.size() == 1) {
            stID = destination.get((int) obj[0]);
            pnodes = p1.getNodeIds();
            if (cost1 < 1) {
                jTextAreaInfo.setText("Distance: " + Math.round(cost1 * 1000) + " m\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            } else {
                jTextAreaInfo.setText("Distance: " + roundTwoDecimals(cost1) + " Km\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            }
            return pnodes;
        }


        LogicalSubPath subPath2 = cm.analyst.shortestPathDijkstra(new PointOnNet(buildingNode), new PointOnNet((int) obj[1]), null);
        PrintUtility.print(System.out, subPath2, true, 30, 0);
        LogicalPath p2 = subPath2.getReferencePath();
        double cost2 = p2.getCosts()[0];
        if (cost1 < cost2) {
            stID = destination.get((int) obj[0]);
            pnodes = p1.getNodeIds();
            //assuming 30km/h
            if (cost1 < 1) {
                jTextAreaInfo.setText("Distance: " + Math.round(cost1 * 1000) + " m\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            } else {
                jTextAreaInfo.setText("Distance: " + roundTwoDecimals(cost1) + " Km\nTravel time: " + minToHour((int) Math.round(cost1 * 2)));
            }
        } else {
            stID = destination.get((int) obj[1]);
            pnodes = p2.getNodeIds();
            if (cost1 < 1) {
                jTextAreaInfo.setText("Distance: " + Math.round(cost2 * 1000) + " m\nTravel time: " + minToHour((int) Math.round(cost2 * 2)));
            } else {
                jTextAreaInfo.setText("Distance: " + roundTwoDecimals(cost2) + " Km\nTravel time: " + minToHour((int) Math.round(cost2 * 2)));
            }
        }

        return pnodes;
    }

    private double roundTwoDecimals(double d) {
        DecimalFormat twoDForm = new DecimalFormat("#.##");
        return Double.valueOf(twoDForm.format(d));
    }

    private String minToHour(int min) {
        int hours = min / 60;
        int minutes = min % 60;
        String time = hours + "h: " + minutes + "min";
        return time;

    }

    private Vector<String> readAddresses(String file) {
        Vector<String> address = new Vector<>();
        address.add(" ");
        try (Scanner read = new Scanner(new FileInputStream(file))) {

            while (read.hasNext()) {
                String[] data = read.nextLine().split(", ");
                address.add(data[1]);
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(DataSupplier.class.getName()).log(Level.SEVERE, null, ex);
        }
        return address;
    }

    private HashMap<Integer, String> closestFireStations(String buildingId) throws SQLException {
        query = "SELECT firestations.geom, firestations.building_id, firestations.building_name"
                + " FROM firestations , Buildings WHERE Buildings.building_ID= '"
                + buildingId
                + "' AND SDO_NN(firestations.geom, buildings.geom, 'sdo_num_res=2')='TRUE'";
        ResultSet rs2 = cm.fetchData(query);
        List<String> fsId = new ArrayList<>();
//        List<Integer> fsNode = new ArrayList<>();
        HashMap<Integer, String> fsNode = new HashMap<>();
        int i = 0;
        while (rs2.next()) {

            STRUCT st2 = (STRUCT) rs2.getObject("geom");
            JGeometry geo2 = JGeometry.load(st2);
            fsId.add(rs2.getString("building_id"));
            buildingName = rs2.getString("building_name");
            map.fireStations.add(new Building(geo2.getPoint(), buildingName));
            fsNode.put(nnToFireStation(fsId.get(i)), fsId.get(i));
            i++;
        }

        return fsNode;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnSearch;
    private javax.swing.JButton btnSubmit;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JCheckBox cbExt;
    private javax.swing.JCheckBox cbFireStation;
    private javax.swing.JCheckBox cbOnFire;
    private javax.swing.JCheckBox cbWater;
    private javax.swing.JComboBox jComboAddress;
    private com.toedter.calendar.JDateChooser jDateFrom;
    private com.toedter.calendar.JDateChooser jDateTo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPopupMenu jPopupMenu1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JTabbedPane jTabbedPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextAreaInfo;
    private javax.swing.JTextArea jTextInfo2;
    private javax.swing.JLabel lblCoordination;
    private javax.swing.JLabel lblCoordination1;
    private javax.swing.JLabel lblQuery;
    private MapViewer map;
    private javax.swing.JRadioButton rbClosedRoad;
    private javax.swing.JRadioButton rbExt;
    private javax.swing.JRadioButton rbFixedroad;
    private javax.swing.JRadioButton rbLocateFire;
    private javax.swing.JRadioButton rbRange;
    private javax.swing.JRadioButton rbWater;
    private javax.swing.JRadioButton rbWholeRegion;
    // End of variables declaration//GEN-END:variables
}
